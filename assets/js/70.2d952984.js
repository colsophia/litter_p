(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{523:function(t,s,n){"use strict";n.r(s);var a=n(56),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"二-数据库范式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二-数据库范式"}},[t._v("#")]),t._v(" 二：数据库范式")]),t._v(" "),n("p",[n("strong",[t._v("部分依赖：")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("举个例子：通过AB能得出C，通过A也能得出C，通过B也能得出C，那么说C部分依赖于AB。\n")])])]),n("p",[n("strong",[t._v("完全函数依赖(Full functional dependency) ：")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("举个例子：通过AB能得出C，但是AB单独得不出C，那么说C完全依赖于AB.\n")])])]),n("p",[n("strong",[t._v("传递函数依赖：")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("举个例子：通过A得到B，通过B得到C，但是C得不到B，B得不到A，那么成C传递依赖于A\n")])])]),n("hr"),t._v(" "),n("p",[n("strong",[t._v("1NF(第一范式)：")]),t._v(" 属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。")]),t._v(" "),n("p",[n("strong",[t._v("2NF(第二范式)：")]),t._v(" 2NF 在 1NF 的基础之上，消除了非主属性对于主属性的部分函数依赖。")]),t._v(" "),n("p",[n("strong",[t._v("3NF(第三范式)：")]),t._v(" 3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。")]),t._v(" "),n("p",[n("strong",[t._v("总结")]),n("br"),t._v("\n1NF：属性不可再分。"),n("br"),t._v("\n2NF：1NF 的基础之上，消除了非主属性对于主属性的部分函数依赖。"),n("br"),t._v("\n3NF：3NF 在 2NF 的基础之上，消除了非主属性对于主属性的传递函数依赖。")])])}),[],!1,null,null,null);s.default=e.exports}}]);