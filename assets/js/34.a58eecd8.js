(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{482:function(t,a,e){"use strict";e.r(a);var n=e(56),o=Object(n.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"spring5官方文档翻译版"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring5官方文档翻译版"}},[t._v("#")]),t._v(" Spring5官方文档翻译版")]),t._v(" "),e("h2",{attrs:{id:"_1、ioc容器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、ioc容器"}},[t._v("#")]),t._v(" 1、IOC容器")]),t._v(" "),e("p",[t._v("IOC：Inversion of Control（控制反转，也称为依赖注入DI【dependency injection】）")]),t._v(" "),e("p",[t._v("IOC是一个过程。对象仅通过构造函数参数、工厂方法的参数或者在对象实例被构造或者从工厂方法返回后在其上设置的属性来定义它们的依赖关系，然后容器在创建 bean 时注入这些依赖项。这个过程从根本上来说是 bean 本身的逆过程(因此得名为控制反转) ，通过使用类的直接构造或服务定位器模式之类的机制来控制其依赖项的实例化或位置。")]),t._v(" "),e("p",[t._v("IOC容器的基础："),e("code",[t._v("org.springframework.beans")]),t._v("和"),e("code",[t._v("org.springframework.context")]),t._v("。")]),t._v(" "),e("p",[t._v("BeanFactory 接口提供了能够管理任何类型对象的高级配置机制。 ApplicationContext 是 BeanFactory 的子接口")]),t._v(" "),e("h3",{attrs:{id:"_1-1-容器概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-容器概述"}},[t._v("#")]),t._v(" 1.1 容器概述")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("ApplicationContext 接口表示 Spring IoC 容器，负责实例化、配置和装配 bean。容器通过读取配置元数据获取关于实例化、配置和组装什么对象的指令。配置元数据用 XML、Java 注释或 Java 代码表示。可以用来表示对象之间的相互依赖关系。【元数据：用于描述资源属性的数据】")])]),t._v(" "),e("li",[e("p",[t._v("Spring 提供了 ApplicationContext 接口的几个实现。在独立应用程序中，通常创建ClassPathXmlApplicationContext 或 FileSystemXmlApplicationContext 的实例。虽然 XML 一直是定义配置元数据的传统格式，但是您可以通过提供少量 XML 配置来声明性地支持这些额外的元数据格式，从而指示容器使用 Java 注释或代码作为元数据格式。")])]),t._v(" "),e("li",[e("p",[t._v("在大多数应用程序方案中，不需要显式用户代码来实例化 Spring IoC 容器的一个或多个实例。例如，在 Web 应用程序场景中，应用程序的 Web.XML 文件中一个简单的八行(或者更多)样板 Web 描述符 XML 通常就足够了(请参阅方便的 application/context 实例化 Web 应用程序)。如果使用 Spring Tools for Eclipse (一个基于 Eclipse 的开发环境) ，只需点击几下鼠标或敲击几下键盘，就可以轻松创建此样板配置。")])]),t._v(" "),e("li")])])}),[],!1,null,null,null);a.default=o.exports}}]);